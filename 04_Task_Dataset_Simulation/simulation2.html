<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLP-Powered Robot Command System</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.8em;
            background: linear-gradient(45deg, #00f5ff, #00c9ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }

        .nlp-section {
            background: rgba(0, 245, 255, 0.1);
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .input-area {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: stretch;
        }

        .command-input {
            flex: 1;
            padding: 15px;
            border: 2px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 16px;
            resize: vertical;
            min-height: 60px;
            font-family: 'Courier New', monospace;
        }

        .command-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .preset-commands {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 15px;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid rgba(0, 245, 255, 0.4);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: rgba(0, 245, 255, 0.3);
            transform: translateY(-1px);
        }

        .process-btn {
            padding: 15px 30px;
            background: linear-gradient(45deg, #00f5ff, #0099cc);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 245, 255, 0.4);
        }

        .nlp-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .analysis-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #00f5ff;
        }

        .analysis-panel h3 {
            margin-top: 0;
            color: #00f5ff;
            font-size: 1.2em;
        }

        .token-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .token {
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }

        .token.action { background: rgba(255, 99, 132, 0.8); }
        .token.object { background: rgba(54, 162, 235, 0.8); }
        .token.location { background: rgba(255, 206, 86, 0.8); }
        .token.parameter { background: rgba(75, 192, 192, 0.8); }
        .token.modifier { background: rgba(153, 102, 255, 0.8); }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 25px;
            margin-top: 25px;
        }

        .simulation-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        canvas {
            width: 100%;
            height: 450px;
            border-radius: 10px;
            background: linear-gradient(to bottom, #1a202c 0%, #2d3748 100%);
            border: 2px solid rgba(0, 245, 255, 0.3);
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .status-section {
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-value {
            color: #00f5ff;
            font-weight: bold;
        }

        .execution-log {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
        }

        .log-entry.info { color: #00f5ff; }
        .log-entry.success { color: #00ff88; }
        .log-entry.warning { color: #ffaa00; }
        .log-entry.error { color: #ff4757; }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #ffaa00, #00ff88);
            transition: width 0.5s ease;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .processing {
            animation: pulse 1s infinite;
        }

        .robot-active {
            filter: drop-shadow(0 0 10px #00f5ff);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ NLP-Powered Robot Command System</h1>
        
        <div class="nlp-section">
            <h2>üß† Natural Language Processing Interface</h2>
            
            <div class="preset-commands">
                <div class="preset-btn" onclick="setPresetCommand(0)">Search & Rescue</div>
                <div class="preset-btn" onclick="setPresetCommand(1)">Supply Drop</div>
                <div class="preset-btn" onclick="setPresetCommand(2)">Hazard Alert</div>
                <div class="preset-btn" onclick="setPresetCommand(3)">Path Clearing</div>
                <div class="preset-btn" onclick="setPresetCommand(4)">Medical Setup</div>
            </div>
            
            <div class="input-area">
                <textarea 
                    id="commandInput" 
                    class="command-input" 
                    placeholder="Enter natural language command (e.g., 'Go to the collapsed building and use thermal sensors to find survivors')"
                ></textarea>
                <button class="process-btn" onclick="processNLCommand()">üî¨ Process Command</button>
            </div>

            <div class="nlp-analysis" id="nlpAnalysis" style="display: none;">
                <div class="analysis-panel">
                    <h3>üìù Parsed Tokens</h3>
                    <div id="tokenDisplay" class="token-list"></div>
                </div>
                <div class="analysis-panel">
                    <h3>üéØ Extracted Intent</h3>
                    <div id="intentDisplay"></div>
                    <div class="confidence-bar">
                        <div id="confidenceBar" class="confidence-fill" style="width: 0%"></div>
                    </div>
                    <small>Confidence: <span id="confidenceText">0%</span></small>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="simulation-area">
                <h3>üéÆ Robot Simulation</h3>
                <canvas id="robotCanvas" width="700" height="450"></canvas>
            </div>
            
            <div class="control-panel">
                <div class="status-section">
                    <h3>üìä System Status</h3>
                    <div class="status-item">
                        <span>NLP Engine:</span>
                        <span class="status-value" id="nlpStatus">Ready</span>
                    </div>
                    <div class="status-item">
                        <span>Robot State:</span>
                        <span class="status-value" id="robotStatus">Standby</span>
                    </div>
                    <div class="status-item">
                        <span>Mission:</span>
                        <span class="status-value" id="missionStatus">None</span>
                    </div>
                    <div class="status-item">
                        <span>Location:</span>
                        <span class="status-value" id="locationStatus">Base</span>
                    </div>
                </div>

                <div class="status-section">
                    <h3>üìã Execution Log</h3>
                    <div class="execution-log" id="executionLog">
                        <div class="log-entry info">System initialized</div>
                        <div class="log-entry info">NLP engine ready</div>
                        <div class="log-entry info">Awaiting command input...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // NLP Processing System
        class RobotNLP {
            constructor() {
                // Intent patterns for disaster response
                this.intentPatterns = {
                    search_survivors: [
                        /\b(find|search|locate|scan)\b.*\b(survivor|people|person|victim)\b/i,
                        /\b(thermal|heat)\b.*\b(sensor|scan|detect)\b/i,
                        /\b(collapsed|debris|rubble)\b.*\b(building|structure)\b/i
                    ],
                    deploy_supplies: [
                        /\b(drop|deploy|deliver|airdrop)\b.*\b(supplies|kit|food|water)\b/i,
                        /\b(coordinate|location|position)\b.*\b(\d+\.?\d*¬∞?[NS])\b/i,
                        /\b(survival|emergency|relief)\b.*\b(kit|package|supplies)\b/i
                    ],
                    hazard_warning: [
                        /\b(warn|alert|danger|hazard)\b/i,
                        /\b(chemical|gas|toxic|leak)\b/i,
                        /\b(radius|area|zone|perimeter)\b/i
                    ],
                    clear_path: [
                        /\b(clear|remove|clean)\b.*\b(debris|obstacle|block)\b/i,
                        /\b(road|path|route|highway)\b/i,
                        /\b(NH|highway|route)\b.*\b(\d+)\b/i
                    ],
                    medical_assistance: [
                        /\b(medical|health|hospital|doctor)\b/i,
                        /\b(camp|center|facility|station)\b/i,
                        /\b(setup|establish|create)\b/i
                    ]
                };

                // Entity extraction patterns
                this.entityPatterns = {
                    location: /\b([A-Z][a-z]+\s*(?:[A-Z][a-z]+)*|(?:\d+\.?\d*¬∞?[NS],?\s*\d+\.?\d*¬∞?[EW]))\b/g,
                    equipment: /\b(thermal|sensor|drone|kit|generator|beacon|LiDAR)\b/gi,
                    quantity: /\b(\d+)\b/g,
                    distance: /\b(\d+)\s*(m|meter|km|kilometer|mile)\b/gi
                };

                // Token classification
                this.tokenTypes = {
                    actions: ['find', 'search', 'locate', 'scan', 'drop', 'deploy', 'deliver', 'warn', 'alert', 'clear', 'remove', 'setup', 'establish'],
                    objects: ['survivor', 'people', 'supplies', 'kit', 'debris', 'obstacle', 'camp', 'facility'],
                    equipment: ['thermal', 'sensor', 'drone', 'generator', 'beacon', 'lidar'],
                    locations: ['building', 'structure', 'road', 'path', 'hospital', 'center'],
                    modifiers: ['collapsed', 'damaged', 'emergency', 'temporary', 'mobile']
                };
            }

            // Main NLP processing function
            processCommand(text) {
                const startTime = Date.now();
                
                // Step 1: Tokenization
                const tokens = this.tokenize(text);
                
                // Step 2: Intent Classification
                const intent = this.classifyIntent(text);
                
                // Step 3: Entity Extraction
                const entities = this.extractEntities(text);
                
                // Step 4: Parameter Mapping
                const parameters = this.mapParameters(intent, entities, text);
                
                const processingTime = Date.now() - startTime;
                
                return {
                    originalText: text,
                    tokens: tokens,
                    intent: intent,
                    entities: entities,
                    parameters: parameters,
                    processingTime: processingTime,
                    confidence: intent.confidence
                };
            }

            // Tokenize and classify tokens
            tokenize(text) {
                const words = text.toLowerCase().match(/\b\w+\b/g) || [];
                return words.map(word => {
                    let type = 'other';
                    
                    for (const [category, list] of Object.entries(this.tokenTypes)) {
                        if (list.includes(word)) {
                            type = category.slice(0, -1); // Remove 's' from category name
                            break;
                        }
                    }
                    
                    return { word, type };
                });
            }

            // Classify intent using pattern matching
            classifyIntent(text) {
                let bestMatch = { intent: 'unknown', confidence: 0 };
                
                for (const [intent, patterns] of Object.entries(this.intentPatterns)) {
                    let matches = 0;
                    for (const pattern of patterns) {
                        if (pattern.test(text)) {
                            matches++;
                        }
                    }
                    
                    const confidence = (matches / patterns.length) * 100;
                    if (confidence > bestMatch.confidence) {
                        bestMatch = { intent, confidence };
                    }
                }
                
                return bestMatch;
            }

            // Extract entities from text
            extractEntities(text) {
                const entities = {};
                
                for (const [type, pattern] of Object.entries(this.entityPatterns)) {
                    const matches = [...text.matchAll(pattern)];
                    if (matches.length > 0) {
                        entities[type] = matches.map(match => match[0]);
                    }
                }
                
                return entities;
            }

            // Map extracted information to robot parameters
            mapParameters(intent, entities, text) {
                const params = {};
                
                // Map based on intent type
                switch (intent.intent) {
                    case 'search_survivors':
                        params.sensor_type = entities.equipment?.find(e => e.toLowerCase().includes('thermal')) ? 'thermal' : 'standard';
                        params.structure_type = text.toLowerCase().includes('building') ? 'building' : 'structure';
                        break;
                        
                    case 'deploy_supplies':
                        params.quantity = entities.quantity?.[0] || '10';
                        params.supply_type = text.toLowerCase().includes('survival') ? 'survival kits' : 'supplies';
                        break;
                        
                    case 'hazard_warning':
                        params.hazard_type = text.toLowerCase().includes('chemical') ? 'chemical' : 'general';
                        params.radius = entities.distance?.[0] || '100m';
                        break;
                        
                    case 'clear_path':
                        params.obstacle_type = 'debris';
                        params.route = entities.location?.[0] || 'unknown';
                        break;
                        
                    case 'medical_assistance':
                        params.facility_type = 'medical camp';
                        params.location = entities.location?.[0] || 'relief center';
                        break;
                }
                
                // Add common parameters
                if (entities.location) {
                    params.target_location = entities.location[0];
                }
                
                return params;
            }
        }

        // Robot Simulation System
        class RobotSimulator {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.robot = {
                    x: 60,
                    y: 350,
                    size: 25,
                    angle: 0,
                    isActive: false,
                    currentMission: null,
                    equipment: [],
                    path: []
                };
                
                this.environment = {
                    buildings: [
                        { x: 200, y: 250, width: 80, height: 120, damaged: false },
                        { x: 350, y: 280, width: 60, height: 90, damaged: true },
                        { x: 500, y: 200, width: 90, height: 170, damaged: false }
                    ],
                    debris: [
                        { x: 450, y: 380, width: 40, height: 15 },
                        { x: 320, y: 385, width: 30, height: 12 }
                    ]
                };
                
                this.effects = [];
                this.animationId = null;
                
                this.draw();
            }

            // Execute mission based on NLP output
            executeMission(nlpResult) {
                this.robot.currentMission = nlpResult;
                this.robot.isActive = true;
                
                // Generate mission path
                this.generateMissionPath(nlpResult.intent.intent, nlpResult.parameters);
                
                // Start animation
                this.animate();
                
                // Log mission start
                this.logMessage(`Mission started: ${nlpResult.intent.intent}`, 'info');
                this.logMessage(`Confidence: ${nlpResult.confidence.toFixed(1)}%`, 'info');
            }

            // Generate path based on mission type
            generateMissionPath(intentType, parameters) {
                const missions = {
                    search_survivors: { target: { x: 350, y: 250 }, duration: 5000 },
                    deploy_supplies: { target: { x: 500, y: 150 }, duration: 3000 },
                    hazard_warning: { target: { x: 400, y: 300 }, duration: 4000 },
                    clear_path: { target: { x: 450, y: 380 }, duration: 6000 },
                    medical_assistance: { target: { x: 200, y: 200 }, duration: 4500 }
                };
                
                const mission = missions[intentType] || missions.search_survivors;
                this.robot.targetX = mission.target.x;
                this.robot.targetY = mission.target.y;
                this.robot.missionDuration = mission.duration;
                
                // Generate equipment based on mission
                this.robot.equipment = this.getEquipmentForMission(intentType);
            }

            // Get equipment for mission type
            getEquipmentForMission(intentType) {
                const equipmentMap = {
                    search_survivors: ['thermal_sensor', 'camera'],
                    deploy_supplies: ['cargo_bay', 'gps'],
                    hazard_warning: ['alert_system', 'chemical_detector'],
                    clear_path: ['manipulator_arm', 'debris_scanner'],
                    medical_assistance: ['medical_kit', 'communication']
                };
                
                return equipmentMap[intentType] || ['standard'];
            }

            // Animation loop
            animate() {
                this.updateRobot();
                this.updateEffects();
                this.draw();
                
                if (this.robot.isActive) {
                    this.animationId = requestAnimationFrame(() => this.animate());
                }
            }

            // Update robot position and state
            updateRobot() {
                if (!this.robot.isActive) return;
                
                const dx = this.robot.targetX - this.robot.x;
                const dy = this.robot.targetY - this.robot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 3) {
                    const speed = 2;
                    this.robot.x += (dx / distance) * speed;
                    this.robot.y += (dy / distance) * speed;
                    this.robot.angle = Math.atan2(dy, dx);
                } else {
                    // Reached target, perform mission action
                    this.performMissionAction();
                    this.robot.isActive = false;
                }
            }

            // Perform mission-specific actions
            performMissionAction() {
                const intent = this.robot.currentMission.intent.intent;
                
                switch (intent) {
                    case 'search_survivors':
                        this.addEffect('thermal_scan', this.robot.x, this.robot.y);
                        this.logMessage('Thermal scan initiated', 'success');
                        this.logMessage('Survivor signatures detected', 'success');
                        break;
                        
                    case 'deploy_supplies':
                        this.addEffect('supply_drop', this.robot.x, this.robot.y);
                        this.logMessage('Supply drop completed', 'success');
                        break;
                        
                    case 'hazard_warning':
                        this.addEffect('warning_signal', this.robot.x, this.robot.y);
                        this.logMessage('Hazard warning activated', 'warning');
                        break;
                        
                    case 'clear_path':
                        this.addEffect('debris_clearing', this.robot.x, this.robot.y);
                        this.logMessage('Path clearing in progress', 'info');
                        this.clearDebris();
                        break;
                        
                    case 'medical_assistance':
                        this.addEffect('medical_setup', this.robot.x, this.robot.y);
                        this.logMessage('Medical facility established', 'success');
                        break;
                }
                
                this.logMessage('Mission completed successfully', 'success');
            }

            // Add visual effects
            addEffect(type, x, y) {
                const effect = {
                    type: type,
                    x: x,
                    y: y,
                    startTime: Date.now(),
                    duration: 3000
                };
                
                this.effects.push(effect);
            }

            // Update effects
            updateEffects() {
                const currentTime = Date.now();
                this.effects = this.effects.filter(effect => 
                    (currentTime - effect.startTime) < effect.duration
                );
            }

            // Clear debris (for path clearing mission)
            clearDebris() {
                setTimeout(() => {
                    this.environment.debris = this.environment.debris.filter(debris => 
                        Math.abs(debris.x - this.robot.x) > 50
                    );
                    this.logMessage('Debris cleared successfully', 'success');
                }, 2000);
            }

            // Main drawing function
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw environment
                this.drawEnvironment();
                
                // Draw effects
                this.drawEffects();
                
                // Draw robot
                this.drawRobot();
            }

            // Draw environment elements
            drawEnvironment() {
                // Draw ground
                this.ctx.fillStyle = '#2d3748';
                this.ctx.fillRect(0, this.canvas.height - 50, this.canvas.width, 50);
                
                // Draw buildings
                this.environment.buildings.forEach(building => {
                    this.ctx.fillStyle = building.damaged ? '#8b4513' : '#4a5568';
                    this.ctx.fillRect(building.x, this.canvas.height - building.height - 50, 
                                    building.width, building.height);
                    
                    if (building.damaged) {
                        // Draw damage marks
                        this.ctx.fillStyle = '#ff4757';
                        this.ctx.fillRect(building.x + 10, this.canvas.height - building.height - 40, 
                                        building.width - 20, 8);
                    }
                });
                
                // Draw debris
                this.environment.debris.forEach(debris => {
                    this.ctx.fillStyle = '#8b4513';
                    this.ctx.fillRect(debris.x, this.canvas.height - 50 - debris.height, 
                                    debris.width, debris.height);
                });
            }

            // Draw robot
            drawRobot() {
                this.ctx.save();
                this.ctx.translate(this.robot.x, this.robot.y);
                this.ctx.rotate(this.robot.angle);
                
                // Robot body
                this.ctx.fillStyle = this.robot.isActive ? '#00f5ff' : '#4169E1';
                this.ctx.fillRect(-this.robot.size/2, -this.robot.size/2, 
                                this.robot.size, this.robot.size);
                
                // Robot head
                this.ctx.fillStyle = '#00c9ff';
                this.ctx.beginPath();
                this.ctx.arc(0, -this.robot.size/2 - 8, 6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Equipment indicators
                if (this.robot.equipment.length > 0) {
                    this.ctx.fillStyle = '#ffaa00';
                    this.robot.equipment.forEach((_, index) => {
                        this.ctx.fillRect(-8 + index * 4, this.robot.size/2 + 2, 3, 6);
                    });
                }
                
                // Activity indicator
                if (this.robot.isActive) {
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([3, 3]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.robot.size + 8, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                this.ctx.restore();
            }

            // Draw visual effects
            drawEffects() {
                const currentTime = Date.now();
                
                this.effects.forEach(effect => {
                    const progress = (currentTime - effect.startTime) / effect.duration;
                    const alpha = 1 - progress;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    
                    switch (effect.type) {
                        case 'thermal_scan':
                            this.drawThermalScan(effect.x, effect.y, progress);
                            break;
                        case 'supply_drop':
                            this.drawSupplyDrop(effect.x, effect.y, progress);
                            break;
                        case 'warning_signal':
                            this.drawWarningSignal(effect.x, effect.y, progress);
                            break;
                        case 'debris_clearing':
                            this.drawDebrisClearing(effect.x, effect.y, progress);
                            break;
                        case 'medical_setup':
                            this.drawMedicalSetup(effect.x, effect.y, progress);
                            break;
                    }
                    
                    this.ctx.restore();
                });
            }

            // Effect drawing functions
            d// Effect drawing functions continued...
            drawThermalScan(x, y, progress) {
                const radius = 30 + progress * 40;
                this.ctx.strokeStyle = '#ff4757';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Heat signatures
                if (progress > 0.5) {
                    this.ctx.fillStyle = '#ff4757';
                    this.ctx.beginPath();
                    this.ctx.arc(x + 20, y - 15, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(x - 15, y + 10, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            drawSupplyDrop(x, y, progress) {
                // Draw parachute
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y - 30 * progress);
                this.ctx.lineTo(x - 15, y - 10 - 30 * progress);
                this.ctx.lineTo(x + 15, y - 10 - 30 * progress);
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw supply crate
                this.ctx.fillStyle = '#ffaa00';
                this.ctx.fillRect(x - 10, y - 5 - 30 * progress, 20, 15);
            }

            drawWarningSignal(x, y, progress) {
                const radius = 20 + progress * 50;
                const gradient = this.ctx.createRadialGradient(x, y, 5, x, y, radius);
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Warning symbol
                this.ctx.fillStyle = '#ff0000';
                this.ctx.beginPath();
                this.ctx.moveTo(x, y - 10);
                this.ctx.lineTo(x + 8, y + 8);
                this.ctx.lineTo(x - 8, y + 8);
                this.ctx.closePath();
                this.ctx.fill();
            }

            drawDebrisClearing(x, y, progress) {
                // Draw clearing effect
                this.ctx.strokeStyle = '#00ff88';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 25 + progress * 30, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Draw arm movement
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + 30 * Math.sin(progress * 10), y - 30 * Math.cos(progress * 10));
                this.ctx.stroke();
            }

            drawMedicalSetup(x, y, progress) {
                // Draw medical tent
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * (1 - progress)})`;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y - 40 * (1 - progress));
                this.ctx.lineTo(x - 30, y - 10 * (1 - progress));
                this.ctx.lineTo(x + 30, y - 10 * (1 - progress));
                this.ctx.closePath();
                this.ctx.fill();
                
                // Draw cross
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(x - 10, y - 25 * (1 - progress));
                this.ctx.lineTo(x + 10, y - 25 * (1 - progress));
                this.ctx.moveTo(x, y - 35 * (1 - progress));
                this.ctx.lineTo(x, y - 15 * (1 - progress));
                this.ctx.stroke();
            }

            // Log messages to UI
            logMessage(message, type = 'info') {
                const logElement = document.getElementById('executionLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logElement.prepend(entry);
                
                // Keep log to 20 entries max
                if (logElement.children.length > 20) {
                    logElement.removeChild(logElement.lastChild);
                }
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.nlp = new RobotNLP();
                this.simulator = new RobotSimulator('robotCanvas');
                this.presetCommands = [
                    "Use thermal sensors to locate survivors in the collapsed apartment near Gandhi Nagar",
                    "Airdrop 50 survival kits to coordinates 13.0827¬∞N, 80.2707¬∞E with high priority",
                    "Issue chemical leak alert within 500m radius of the damaged factory",
                    "Remove debris blocking Route NH48 between kilometer markers 120 and 125",
                    "Set up temporary medical camp at the flood relief center in Cuddalore"
                ];
                
                this.initEventListeners();
            }
            
            initEventListeners() {
                document.getElementById('commandInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.processNLCommand();
                    }
                });
            }
            
            setPresetCommand(index) {
                if (index >= 0 && index < this.presetCommands.length) {
                    document.getElementById('commandInput').value = this.presetCommands[index];
                }
            }
            
            processNLCommand() {
                const commandInput = document.getElementById('commandInput');
                const commandText = commandInput.value.trim();
                
                if (!commandText) {
                    alert('Please enter a command');
                    return;
                }
                
                // Show processing state
                document.getElementById('nlpStatus').textContent = 'Processing...';
                document.getElementById('nlpStatus').classList.add('processing');
                document.getElementById('robotStatus').textContent = 'Processing Command';
                
                // Clear previous analysis
                document.getElementById('nlpAnalysis').style.display = 'none';
                
                // Simulate processing delay
                setTimeout(() => {
                    const result = this.nlp.processCommand(commandText);
                    this.displayNLPResults(result);
                    this.simulator.executeMission(result);
                    
                    // Update UI
                    document.getElementById('nlpStatus').textContent = 'Ready';
                    document.getElementById('nlpStatus').classList.remove('processing');
                    document.getElementById('robotStatus').textContent = 'Executing Mission';
                    document.getElementById('missionStatus').textContent = result.intent.intent.replace(/_/g, ' ');
                    
                    if (result.parameters.target_location) {
                        document.getElementById('locationStatus').textContent = result.parameters.target_location;
                    }
                }, 800);
            }
            
            displayNLPResults(result) {
                // Show analysis section
                document.getElementById('nlpAnalysis').style.display = 'grid';
                
                // Display tokens
                const tokenDisplay = document.getElementById('tokenDisplay');
                tokenDisplay.innerHTML = '';
                
                result.tokens.forEach(token => {
                    const tokenElement = document.createElement('span');
                    tokenElement.className = `token ${token.type}`;
                    tokenElement.textContent = token.word;
                    tokenDisplay.appendChild(tokenElement);
                });
                
                // Display intent
                document.getElementById('intentDisplay').textContent = 
                    result.intent.intent.replace(/_/g, ' ');
                
                // Update confidence
                document.getElementById('confidenceBar').style.width = `${result.intent.confidence}%`;
                document.getElementById('confidenceText').textContent = 
                    `${result.intent.confidence.toFixed(1)}%`;
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.uiController = new UIController();
            
            // Make preset command function available globally
            window.setPresetCommand = (index) => uiController.setPresetCommand(index);
            window.processNLCommand = () => uiController.processNLCommand();
            
            // Update robot status when mission completes
            const simulator = uiController.simulator;
            const originalExecuteMission = simulator.executeMission.bind(simulator);
            
            simulator.executeMission = function(nlpResult) {
                originalExecuteMission(nlpResult);
                
                // Update status when mission completes
                setTimeout(() => {
                    document.getElementById('robotStatus').textContent = 'Standby';
                }, nlpResult.intent.intent === 'clear_path' ? 8000 : 5000);
            };
        });
    </script>
</body>
</html>